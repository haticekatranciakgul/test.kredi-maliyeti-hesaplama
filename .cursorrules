0. Debugging
debugging
breakpoints
developer tools (components tab)
developer tools (profiler tab)
developer tools (flamegraph Tab)
developer tools (ranked tab)
developer tools (timeline tab)
Best tools to debbugging your React code
  - BrowserStack Automate
  - Chrome DevTools
  - Zipy.ai
  - React Developer Tool
  - Redux Dev Tools
  - Why Did You Render
  - Reactotron
  - Error Boundaries
  - Jest
  - Storybook
  - Enzyme
  - React Cosmos
  - React Sight
  - LogRocket
1. Use functional components instead of class components
Functional components are simpler and support Hooks. (Fonksiyonel bileÅŸenler daha basittir ve Hook'larÄ± destekler.) Functional Component

Syntax : function, const Component = () => {}
State Management : useState()
Lifecycle : useState(), useReducer()
Readability : Easy
Reusability : Easy
Performance : Good
Test : Easy Class Component
Syntax : class Component extends React.Component {}
State Management : this.state and this.setState()
Lifecycle : componentDidMount, componentDidUpdate
Readability : Hard
Reusability : Hard
Performance : Slow
Test : Hard
2. Component Composition
Build components by combining smaller ones. (BileÅŸenleri, daha kÃ¼Ã§Ã¼k bileÅŸenleri birleÅŸtirerek oluÅŸturun.) props = {children}
3. Avoid Using Inline Styles
Use CSS or styled-components for maintainability. (SÃ¼rdÃ¼rÃ¼lebilirlik iÃ§in CSS veya styled-components kullanÄ±n. BileÅŸene Ã¶zel CSS modal.css)
4. Use Arrow Functions
Arrow functions are cleaner and keep the context (this). (Arrow function'lar daha temizdir ve this baÄŸlamÄ±nÄ± korur.)
5. Use the lazy() and Suspense() Functions
Split code to improve load time. (Kodu bÃ¶lerek yÃ¼kleme sÃ¼resini azaltÄ±n.)
6. Optimize Component Rendering
Use React.memo, useMemo, and useCallback. (React.memo, useMemo ve useCallback kullanarak yeniden render'Ä± azaltÄ±n.)
7. Use Type Declaration Tools
Use TypeScript or PropTypes. TypeScript veya PropTypes ile veri tÃ¼rlerini tanÄ±mlayÄ±n.
8. Use a Linter and Follow its rules (ESLint, Prettier)
Ensures consistent code style. (TutarlÄ± bir kod stili saÄŸlar.)
9. Test Your Code
Use testing tools like Jest or React Testing Library. (Jest veya React Testing Library gibi araÃ§larla test yapÄ±n.)
10. Write Test Cases
Make sure each component works as expected. (Her bileÅŸenin beklenildiÄŸi gibi Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulayÄ±n.) - Jest: En yaygÄ±n kullanÄ±lan test framework'Ã¼dÃ¼r, Ã¶zellikle React projelerinde. - React Testing Library: KullanÄ±cÄ± davranÄ±ÅŸlarÄ±nÄ± test etmek iÃ§in mÃ¼kemmeldir. - Enzyme: Ã–zellikle eski projelerde yaygÄ±n. - Cypress: E2E testler iÃ§in kullanÄ±lÄ±r. - Mocha + Chai: Daha esnek bir test yapÄ±sÄ± saÄŸlar.
11. Higher-Order Components (HOC)
Reuse component logic by wrapping them. (BileÅŸen mantÄ±ÄŸÄ±nÄ± yeniden kullanmak iÃ§in sarmalayÄ±n.)
    withUserData.js

    import React, { useEffect, useState } from "react";

    const withUserData = (WrappedComponent) => {
      return function WithUserDataComponent(props) {
        const [userData, setUserData] = useState(null);
        const [loading, setLoading] = useState(true);

        useEffect(() => {
          const fetchUserData = async () => {
            try {
              const res = await fetch("https://jsonplaceholder.typicode.com/users/1");
              const data = await res.json();
              setUserData(data);
              setLoading(false);
            } catch (error) {
              console.error("Error fetching user data:", error);
              setLoading(false);
            }
          };

          fetchUserData();
        }, []);

        if (loading) {
          return <p>Loading user data...</p>;
        }

        return <WrappedComponent userData={userData} {...props} />;
      };
    };

    export default withUserData;


    UserInfo.js

    import React from "react";

    const UserInfo = ({ userData }) => {
      return (
        <div>
          <h2>User Info</h2>
          <p><strong>Name:</strong> {userData.name}</p>
          <p><strong>Email:</strong> {userData.email}</p>
          <p><strong>City:</strong> {userData.address.city}</p>
        </div>
      );
    };

    export default UserInfo;


    App.js

    import React from "react";
    import withUserData from "./withUserData";
    import UserInfo from "./UserInfo";

    const EnhancedUserInfo = withUserData(UserInfo);

    function App() {
      return (
        <div className="App">
          <h1>Higher-Order Component Demo</h1>
          <EnhancedUserInfo />
        </div>
      );
    }

    export default App;
withUserData, UserInfo bileÅŸenini sarar.
User verisini alÄ±r ve userData prop'u olarak verir.
Ve App iÃ§inde bu haliyle kullanÄ±lÄ±r: <EnhancedUserInfo />
12. DRY (Don't Repeat Yourself)
Avoid repeating code, create reusable functions. (Kendini tekrar etme, tekrar kullanÄ±labilir fonksiyonlar yaz.)
13. Separate Stateful Aspect From Rendering
Keep logic and UI separate. (Durum yÃ¶netimini gÃ¶rsel kÄ±sÄ±mdan ayÄ±r.)
14. Clean Code ( deleting any commented-out code, removing zombie code, and restructuring. ), code splitting
Remove commented or unused code. (Yorum satÄ±rlarÄ±nÄ± ve kullanÄ±lmayan kodlarÄ± sil.)
15. Sorting Your Imports Correctly in React
Keep imports organized (libraries, components, styles). (Ä°Ã§e aktarmalarÄ± dÃ¼zenli tut (Ã¶nce kÃ¼tÃ¼phaneler, sonra bileÅŸenler, stiller vb.).)

Ideal Import Order in React (Ä°deal Import SÄ±ralamasÄ± (Genel Kural)) . Third-party libraries (React, Redux, Axios, vs...) . Absolute imports (context, hooks, utils, etc...) . Relative imports (components, local files...) . Styles (CSS, SCSS, styled-components...)

Third-party libraries
import React, { useState } from "react";
import { useDispatch } from "react-redux";
import axios from "axios";
Absolute imports (varsayÄ±lan olarak @/utils veya context gibi)
import { ThemeContext } from "@/context/ThemeContext";
import useAuth from "@/hooks/useAuth";
Relative imports
import Navbar from "../components/Navbar";
import Button from "./Button";
Styles
import "./App.css";
import "../styles/theme.scss";
16. Keep your key prop unique across your whole App (map key={index})
Use unique key props in lists. Avoid index. (Liste elemanlarÄ±nda benzersiz key kullan, index kullanmaktan kaÃ§Ä±n.)
Bad Practice (YanlÄ±ÅŸ):

{items.map((item, index) => (
  <div key={index}>{item.name}</div>
))}
Good Practice (DoÄŸru):

{items.map((item) => (
  <div key={item.id}>{item.name}</div>
))}
17. Use shorthand for boolean props
Use disabled instead of disabled={true}. (disabled={true} yerine sadece disabled yaz.)
18. Avoid curly braces for string props
Use title="Hello" not title={"Hello"}. (title={"Hello"} yerine title="Hello" kullan.)
19. Erase non-html attributes when spreading props
Avoid passing unknown props to DOM. (HTML olmayan props'larÄ± DOM'a yayma.)
20. Integrate self-closing tags when no children are needed
Use <Input /> instead of <Input></Input> (Ã‡ocuk bileÅŸen yoksa kendini kapatan etiket kullan.)
21. Follow common naming conventions
Type	Convention	Example
Components	PascalCase	LoginForm
Component file	PascalCase	LoginForm.js
Component folder	PascalCase	/components/LoginForm
Props	camelCase	userEmail, onClick
Variables	camelCase	let totalPrice = 99
Functions	camelCase	getUserProfile()
Utility functions	camelCase	formatDate
Utility functions file	camelCase	formatDate.js
Hooks	camelCase	useFetchData()
Hook file	kebab-case	use-auth.js
Redux Slice	camelCase	userSlice.js
Redux Slice name	camelCase	userSlice
Context file	kebab-case	auth-context.js
Constants	SCREAMING_SNAKE_CASE	API_BASE_URL
Route paths	kebab-case	/user-profile, /login-page
Style file	kebab-case	login-form.module.css
Asset file	kebab-case	logo-dark.svg
Routes	kebab-case	/user-profile, /login-page
Icons folder	kebab-case	/icons/
Test file	PascalCase	LoginForm.test.js
Component Folder Singular /Button, /Card, /Navbar
Collections Folder Plural /components, /hooks, /pages, /services, /utils
22. Github repostiory naming conventions standarts word-word
Purpose	Naming Example
App or Website	blog-platform, ecommerce-store
Library / Package	react-form-builder, date-utils
Tutorials / Learning	react-hooks-tutorial, js-30-day-challenge
API Backends	notes-api, auth-service
UI Components	mui-datepicker, tailwind-card-grid
23. Keep a clear and standart folder structure
  src/
â”œâ”€â”€ app/                     # Redux store konfigÃ¼rasyonu
â”‚   â””â”€â”€ store.js
â”‚
â”œâ”€â”€ features/                # TÃ¼m slice'lar ve ilgili logic (feature-based architecture)
â”‚   â”œâ”€â”€ auth/                # Ã–rnek feature: authentication
â”‚   â”‚   â”œâ”€â”€ authSlice.js
â”‚   â”‚   â”œâ”€â”€ authAPI.js
â”‚   â”‚   â”œâ”€â”€ AuthPage.jsx
â”‚   â”‚   â””â”€â”€ authSelectors.js
â”‚   â”‚
â”‚   â”œâ”€â”€ products/            # Ã–rnek feature: products
â”‚   â”‚   â”œâ”€â”€ productsSlice.js
â”‚   â”‚   â”œâ”€â”€ productsAPI.js
â”‚   â”‚   â”œâ”€â”€ ProductList.jsx
â”‚   â”‚   â””â”€â”€ productSelectors.js
â”‚   â”‚
â”‚   â””â”€â”€ ...                  # DiÄŸer feature'lar
â”‚
â”œâ”€â”€ components/             # Reusable components (UI widgets)
â”‚   â”œâ”€â”€ Navbar.jsx
â”‚   â”œâ”€â”€ Button.jsx
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ layouts/                # Sayfa yapÄ±sÄ±nÄ± oluÅŸturan layout bileÅŸenleri
â”‚   â”œâ”€â”€ MainLayout.jsx
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ pages/                  # Route edilen sayfalar (React Router ile)
â”‚   â”œâ”€â”€ HomePage.jsx
â”‚   â”œâ”€â”€ LoginPage.jsx
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ routes/                 # Route tanÄ±mlamalarÄ±
â”‚   â””â”€â”€ AppRoutes.jsx
â”‚
â”œâ”€â”€ services/               # API servisleri (axios instance vs.)
â”‚   â”œâ”€â”€ axios.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ hooks/                  # Custom React Hooks
â”‚   â”œâ”€â”€ useAuth.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ utils/                  # YardÄ±mcÄ± fonksiyonlar
â”‚   â”œâ”€â”€ formatDate.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ constants/              # Sabit deÄŸerler (API endpointleri, renkler vs.)
â”‚   â”œâ”€â”€ api.js
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ assets/                 # GÃ¶rseller, ikonlar, stiller
â”‚   â”œâ”€â”€ images/
â”‚   â”œâ”€â”€ icons/
â”‚   â””â”€â”€ styles/
â”‚
â”œâ”€â”€ index.js                # UygulamanÄ±n giriÅŸ noktasÄ±
â””â”€â”€ App.js                  # Root bileÅŸeni
constants, config folder structure

ğŸ“ Proje KlasÃ¶r YapÄ±sÄ± AÃ§Ä±klamasÄ±
KlasÃ¶r	Ne Ä°Ã§in KullanÄ±lÄ±r?	Ä°Ã§erik Ã–rnekleri
constants	DeÄŸiÅŸmeyen sabit deÄŸerler	Action Types, Routes, Colors, Status Codes
config	Ortama baÄŸlÄ± ayarlar ve API yapÄ±landÄ±rmalarÄ±	API URL, Firebase, Feature Flags, Env Settings
24. Apply SOLID Principles
25. Coding performance improvement, use efficient code
26. Divide large components into small components
27. Dont do over nesting
28. Use the comments when requirements
29. Use state manangement (Redux)
30. Use reusable units, readablity, maintability, flexable
31. Commit message standard
32. Todo standard: // TODO: Will be converted to enum
33. Gitignore template
34. Debugging Methods
35. Clean console.log for production code
36. Api naming convention format
https://medium.com/@nadinCodeHat/rest-api-naming-conventions-and-best-practices-1c4e781eb6a5

37. Template to do create
38. Use React best practice
39. Use API layer (in services)
40. Response model
Member names SHOULD be camel-cased (i.e., wordWordWord)
Member names SHOULD start and end with a character â€œa-zâ€ (U+0061 to U+007A)
Member names SHOULD contain only ASCII alphanumeric characters (i.e., â€œa-zâ€, â€œA-Zâ€, and â€œ0-9â€)
(Veri kontrolÃ¼: API'den gelen verinin beklediÄŸimiz yapÄ±ya uygun olup olmadÄ±ÄŸÄ±nÄ± kontrol ederiz.
Tip gÃ¼venliÄŸi: Hangi alanÄ±n ne tipte olduÄŸunu biliriz.
Kod tamamlama / IntelliSense: IDE daha rahat yardÄ±m eder.)
41. Rest API standarts
Singleton and Collection Resources /customers //is a collection resource /customers/{id} // is a singleton resource
Collection and Sub-collection Resources /customers //is a collection resource /customers/{id}/accounts // is a sub-collection resource
Use nouns to represent resources /device-management/managed-devices /device-management/managed-devices/{device-id} /user-management/users /user-management/users/{id}
Document
http://api.example.com/device-management/managed-devices/{device-id} http://api.example.com/user-management/users/{id} http://api.example.com/user-management/users/admin
Collection
/device-management/managed-devices /user-management/users /user-management/users/{id}/accounts
Store /song-management/users/{id}/playlists
Use forward slash (/) to indicate hierarchical relationships /device-management /device-management/managed-devices /device-management/managed-devices/{id} /device-management/managed-devices/{id}/scripts /device-management/managed-devices/{id}/scripts/{id}
Do not use trailing forward slash (/) in URIs http://api.example.com/device-management/managed-devices/ http://api.example.com/device-management/managed-devices /This is much better version/
Use hyphens (-) to improve the readability of URIs http://api.example.com/devicemanagement/manageddevices/ http://api.example.com/device-management/managed-devices /This is much better version/
Do not use underscores ( _ ) http://api.example.com/inventory-management/managed-entities/{id}/install-script-location //More readable http://api.example.com/inventory-management/managedEntities/{id}/installScriptLocation //Less readable
Use lowercase letters in URIs http://api.example.org/my-folder/my-doc
Do not use file extensions /device-management/managed-devices.xml /Do not use it/ /device-management/managed-devices /This is correct URI/
Never use CRUD function names in URIs HTTP GET /device-management/managed-devices //Get all devices HTTP POST /device-management/managed-devices //Create new Device HTTP GET /device-management/managed-devices/{id} //Get device for given Id HTTP PUT /device-management/managed-devices/{id} //Update device for given Id HTTP DELETE /device-management/managed-devices/{id} //Delete device for given Id
Use query component to filter URI collection /device-management/managed-devices /device-management/managed-devices?region=USA /device-management/managed-devices?region=USA&brand=XYZ /device-management/managed-devices?region=USA&brand=XYZ&sort=installation-date
Do not Use Verbs in the URI /device-management/managed-devices/{id}/scripts/{id}/execute //DON't DO THIS! /device-management/managed-devices/{id}/scripts/{id}/status //POST request with action=execute
42. Performance Optimization with Single Fetch Requests
Why use 1 fetch instead of 3?
Better performance Fetching all data at once makes the page load faster. Fewer network calls = quicker response.

Less load on the server Instead of handling 3 separate requests, the server processes only 1. This reduces server CPU and memory usage â€” especially important for high-traffic apps.

Cleaner and simpler code Handling data from one response is easier than managing multiple async calls. Fewer lines of code = fewer bugs.

Reduced network usage Especially helpful for users on mobile or slow networks. Browsers limit how many requests can be sent at the same time â€” too many slows everything down.

âŒ Donâ€™t: /user, /posts, /comments â†’ 3 fetch calls âœ… Do: /allData â†’ 1 fetch with everything included